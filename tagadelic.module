<?php
/**
 * @file tagadelic.module
 * Library to build tagclouds.
 * @author BÃ¨r Kessels <ber@webschuur.com>
 * @link http://webschuur.com
 */

/**
 * TagadelicCloud, contains a list of tags
 */
class TagadelicCloud {
  private $id = ""; # An identifier for this cloud. Must be unique.
  private $tags = array(); # List of the tags in this cloud.
  private $steps        = 6;  #Amount of steps to weight the cloud in. Defaults to 6. Means: 6 different sized tags.
  private $needs_recalc = true;

  function __construct($id, $terms = array()) {
  }

  //Setters
  public function set_id($id) {
    $this->id = $id;
    return $this;
  }
  //Getters 
  public function get_id() {
    return $this->$id;
  }
  public function get_tags() {
    return $this->$tags;
  }
  /**
   * Add a new tag to the cloud
   * @param $tag TagadelicTag
   *   instance of TagadelicTag.
   *
   * return $this, for chaining.
   */
  public function add_tag($tag) {
    $this->tags[] = $tag;
    return $this;
  }

  /**
   * Instantiate and add a new tag to the cloud.
   * Wraps around "new TagadelicTag()" and adds to tags array.
   * @param id See TagadelicTag();
   * @param $name See TagadelicTag();
   * @param $description See TagadelicTag();
   * @param $link See TagadelicTag();
   *
   * returns $this, for chaining.
   */
  function create_and_add_tag($id, $name, $count, $description = "", $link = NULL) {
    return $this->add_tag(new TagadelicTag($id, $name, $count, $description, $link));
  }

  /**
   * (Re)calculates the weights on the tags.
   * @param $recalculate. Optional flag to enfore recalculation of the weights for the tags in this cloud.
   *        defaults to FALSE, meaning the value will be calculated once per cloud.
   */
  private function recalculate() {
    $tags = array();
    // Find minimum and maximum log-count.
    $min = 1e9;
    $max = -1e9;
    foreach ($this->tags as $id => $tag) {
      $min = min($min, $tag->distributed());
      $max = max($max, $tag->distributed());
      $tags[$id] = $tag;
    }
    // Note: we need to ensure the range is slightly too large to make sure even
    // the largest element is rounded down.
    $range = max(.01, $max - $min) * 1.0001;
    foreach ($tags as $id => $tag) {
      $this->tags[$id]->set_weight(1 + floor($this->steps * ($tag->distributed() - $min) / $range));
    }
  }
  /**
   * Fetches a cloud from cache; using Drupals own cache.
   * @param $cache_id, the ID used to build the cloud.
   */
  function cache_get($id) {
    $cache_id = "tagadedelic_$id";
    return unserialize(cache_get($cache_id));
  }

  /**
   * Writes the cloud to cache. Will recalculate if needed.
   */
  function cache_set() {
    $cache_id = "tagadedelic_{$this->id}";
    cache_set($cache_id, $this);
    return $this;
  }
}

/**
 * Tag
 */
class TagadelicTag {
  //available trough getters and setters only.
  private $id   = 0;
  private $name = "";# A human readable name for this tag.
  private $description = "";# A human readable piece of HTML-formatted text.

  //available trough setters only.
  private $link = ""; # Where this tag will point to. If left empty, tag will not be linked. Can be a full url too.
  private $count = 0; # Absolute count for the weight. Weight, i.e. tag-size will be extracted from this.
  private $dirty = true;

  //available trough getters only.
  private $weight = 0.0;

  function __construct($id, $name, $count, $description = "", $link = NULL) {
  }

  public function __ToString() {
    $this->clean();
    return l($this->name, $this->link, array("title" => $this->description));
  }

  /**
   * Getters
   **/
  public function get_id() {
    return $this->id;
  } 
  public function get_name() {
    $this->clean();
    return $this->name;
  }
  public function get_description() {
    $this->clean();
    return $this->description;
  }
  public function get_weight() {
    $this->recalculate();
    return $this->weight;
  }

  /**
   * Setters
   **/
  public function set_id($id) {
    $this->id = $id;
  }
  public function set_name($name) {
    $this->name = $name;
  }
  public function set_description($description) {
    $this->description = $description;
  }
  public function set_link($link) {
    $this->link = $link;
  }
  public function set_count($count) {
    $this->count = $count;
  }
  /**
   * Flag $name and $description as dirty; none-cleaned.
   *  BEWARE! This will probably lead to double escaping, unless you know what you are doing.
   */
  public function force_dirty() {
    $this->dirty = true;
  }
  /**
   * Flag $name and $description as safe. 
   *  XSS-escaping and sanitizing is left to implementer. 
   *  BEWARE! Only enforce when you know what you are doing. Seriously!
   */
  public function force_clean() {
    $this->dirty = false;
  }


  /**
   * Calculates a more evenly distributed value.
   */
  public function distributed() {
    return log($this->count);
  }

  /**
    * Utility, to enforce XSS filtering on strings before they are
    * printed or returned.
    **/
  private function clean() {
    if ($this->dirty) {
      $this->name = check_plain($name);
      $this->description = check_plain($this->description);
    }
  }
}
